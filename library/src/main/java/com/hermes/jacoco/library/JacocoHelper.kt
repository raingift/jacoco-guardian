package com.hermes.jacoco.library

import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.OutputStream

/**
 * Jacoco Helper Class
 * @param localDirPath Local file directory path, temporarily storing ec files
 * @param deviceDirPath Terminal device directory path, generate ec files
 */
class JacocoHelper(var localDirPath: String, var deviceDirPath: String) {

    companion object {
        private const val TAG = "JacocoHelper"
    }

    private var logger: ILogger? = null

    init {
        localDirPath = "$localDirPath/build/outputs/code_coverage/"
        deviceDirPath = "$deviceDirPath/coverage.ec"
    }

    /**
     * Generate .ec file
     * @param isForceUpdated whether to force the re-creation of the .ec file
     */
    fun generateEcFile(isForceUpdated: Boolean, callback: ((GenerateResult) -> Unit)? = null) {
        if (deviceDirPath.isEmpty()) {
            logger?.e(TAG, "deviceDirPath must not be null or empty!!!")
            return
        }

        var out: OutputStream? = null
        val coverageFilePath = File(deviceDirPath)

        try {
            if (isForceUpdated && coverageFilePath.exists()) {
                coverageFilePath.delete()
                logger?.d(TAG, "generateEcFile: Clear old .ec files")
            }
            if (!coverageFilePath.exists()) {
                coverageFilePath.createNewFile()
            }
            out = FileOutputStream(coverageFilePath.path, true)
            val agent = Class.forName("org.jacoco.agent.rt.RT")
                .getMethod("getAgent")
                .invoke(null)
            out.write(
                agent.javaClass.getMethod("getExecutionData", Boolean::class.javaPrimitiveType)
                    .invoke(agent, false) as ByteArray
            )
        } catch (e: Exception) {
            logger?.e(TAG, "method reflect: ${e.message}")
            callbackResult(REFLECTION_FAIL, "method reflect: ${e.message}", callback)
        } finally {
            try {
                out?.close()
                logger?.d(TAG, "out close: $coverageFilePath")
                callbackResult(SUCCESS, "success generate .ec file!", callback)
            } catch (e: IOException) {
                callbackResult(IO_FAIL, "out close: ${e.message}", callback)
                logger?.e(TAG, "out close: ${e.message}")
                e.printStackTrace()
            }
        }
        logger?.d(TAG, getAdbPullCmd())
    }

    private fun callbackResult(
        code: Int,
        msg: String,
        callback: ((GenerateResult) -> Unit)?,
    ) {
        callback?.invoke(
            GenerateResult(
                code,
                GenerateData(msg, localDirPath, deviceDirPath)
            )
        )
    }


    /**
     * Export the .ec file generated by jacoco to the project-related directory
     * Output to console
     * @return adb command
     */
    fun getAdbPullCmd(): String {
        val adb = "adb pull $deviceDirPath $localDirPath"
        return "Export .ec file command line: $adb"
    }

    fun printDirPathInfo() {
        logger?.d(TAG, "localDirPath: $localDirPath >>> deviceDirPath: $deviceDirPath")
    }

    fun setLogger(logger: ILogger) {
        this.logger = logger
    }

}